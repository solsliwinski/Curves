#include "Support/SupportHeader.h"
#include "Math/GeneralizedVector.h"
#include "Curve.h"
#include "CurveInl.h"
#include "CurveMaker.h"

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CurveMaker --------------------------------
//
///////////////////////////////////////////////////////////////////////////////
const float CurveMaker::fMinAngErrTol = 0.000001745f; // 1/10000 of a degree.
const float CurveMaker::fMinLinErrTol = 0.0000001f;   // 1/10000 of a millimeter.

CurveData * CurveMaker::fitCurve(
							const CurveType * ptype, 
							u32               icur_curve, 
							u32  *            pcurve_idx, 
							u32  *            pcurve_size
							)
{
	PROFILE_CURVE_SOLVER_CALL(CurveMaker::fitCurve);

	// Prefetch some member variables.
	const u32 dim = nDimensions;
	const u32 deg = nDegree;

	// Get temporary curve memory work area.
	s32    itmp_curve = getNextCurveIndex(icur_curve);
	byte * ploc       = getCurveData(itmp_curve);
	u32 iknot_start   = 0;
	u32 isample_start = 0;

	while(isample_start < nSamples)
	{
		u32 nknots = 0;
		pKnots[iknot_start + nknots++] = float(isample_start++);

		if(nMakerFlags & cmf_AllowCuts)
		{
			const float cut_tol2 = fCutTol * fCutTol;

			for(u32 n = nSamples - 1; isample_start < n; isample_start++)
			{
				const float * s0 = pSamples + isample_start * dim;
				const float * s1 = pSamples + (isample_start + 1) * dim;

				float e2 = CurveCalcErrorSq(s0,s1,dim,nEvalFlags);
				if(e2 > cut_tol2)
				{
					// Tolerance was exceeded, we've detected a cut.
					break;
				}
			}
		}
		else
		{
			// Simple case, advance to the end.
			isample_start = nSamples - 1;
		}

		ASSERT(iknot_start + nknots < nMaxKnots);
		pKnots[iknot_start + nknots++] = float(isample_start++);
		ASSERT(pKnots[iknot_start] < pKnots[iknot_start + nknots - 1]);

		for(;;)
		{
			// Solve control points for current curve segment.
			solveControls(pKnots,pCtrls,iknot_start,nknots);

			u32 ncurve_knots = iknot_start + nknots;
			u32 ncurve_size  = 0;

			// Create curve of all segments processed so far, so we can measure error.
			CurveData * pcd = ptype->createCurve(
										pKnots,pCtrls,
										ncurve_knots,nDimensions,nDegree,
										nEvalFlags,
										&ncurve_size,ploc,nCurveSize);

			if(!pcd)
			{
				LOG(lg_Error,"Failed to create curve of type %s.\n",ptype->getName());
				return NULL;
			}

			// Verify endpoint constraints for current segment have been met.
			ASSERT_CONSTRAINTS(*pcd,pKnots,iknot_start,nknots);

			if(iknot_start > 0)
			{
				// Copy knots for previous curve segments, so temp knot buffer is up-to-date.
				memcpy(pTmpKnots,pKnots,iknot_start * sizeof(float));
			}

			// Subdivide knot vector for current segment, writing results to tmp knot buffer.
			u32 nnew_knots;
			u32 res = subdivideKnots(ptype,iknot_start,nknots,*pcd,&nnew_knots);

			switch(res)
			{
			case sr_Continue:

				// Knots required subdivision, update knot data and continue.
				nknots = nnew_knots;
				mswap(pKnots,pTmpKnots);
				continue;

			case sr_Success:

				*pcurve_idx  = itmp_curve;
				*pcurve_size = ncurve_size; 

				if(nMakerFlags & cmf_AllowKnotReduction)
				{
					// Curve is within error tolerances. Now see if we can remove any superfluous knots.
					pcd = reduceCurveKnots(ptype,iknot_start,nknots,itmp_curve,pcurve_idx,pcurve_size);
				}

				if(isample_start == nSamples)
				{
					// All samples have been processed, we're done!
					return pcd;	
				}

				break;

			case sr_Failure:

				// Subdivision failed, possibly due to round-off error generated by the solver, or quantization.
				*pcurve_idx  = itmp_curve;
				*pcurve_size = ncurve_size; 

				// Knots may have been added before knot limit was hit.
				mswap(pKnots,pTmpKnots);

				if(isample_start == nSamples)
				{
					// Return the curve, but tolerance wasn't achieved.
					return pcd;
				}

				break;
			}

			// Finish off current segment.  Trickier than it might seem.
			switch(res)
			{
			case sr_Success:
			case sr_Failure:
				{
					// Duplicate control endpoints of constant segment.
					float RESTRICT_PTR pc = pCtrls + (iknot_start + nnew_knots + deg - 1) * dim;
					const float * plast   = pCtrls + (iknot_start + nnew_knots + deg - 2) * dim;
					const float * pend    = plast + dim;

					u32 i;
					for(i = 0; i <= deg; i++)
					{	
						const float * pl = plast;
						while(pl != pend)
							*pc++ = *pl++;
					}
					
					// Duplicate knots for end of current segment.
					const float knot_end = pKnots[iknot_start + nnew_knots - 1];
					for(i  = 0; i < deg; i++)
					{
						ASSERT(iknot_start + nnew_knots < nMaxKnots);
						pKnots[iknot_start + nnew_knots] = knot_end;
						nnew_knots++;
					}

					// Duplicate knots for end of constant segment.
					for(i = 0; i < deg; i++)
					{
						ASSERT(iknot_start + nnew_knots < nMaxKnots);
						pKnots[iknot_start + nnew_knots] = knot_end + 1.f;
						nnew_knots++;
					}

					// Advance past knots used by segment we just finished.
					iknot_start = iknot_start + nnew_knots;
				}
				break;
			}

			break;
		}
	}

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
u32 CurveMaker::subdivideKnots(
					const CurveType *  ptype,
					u32                iknot_start,
					u32                nknots,
					const CurveData &  cd, 
					u32 *              pcount
					)
{
	PROFILE_CURVE_SOLVER_CALL(CurveMaker::subdivideKnots);
	ASSERT(nknots >= 2);
	const float err_tol2 = fErrTol * fErrTol;
	const float oo_max_knot = 1.f / pKnots[iknot_start + nknots - 1];
	
	s32 ioverflow = -1;
	s32 icur = -1;
	u32 idst = 0;
	u32 nres = sr_Success;

	const float * pknots = pKnots + iknot_start;
	float *   ptmp_knots = pTmpKnots + iknot_start;
	
	for(u32 i = 0, n = nknots - 1; i < n; i++)
	{
		// Insert old knot value.
		ASSERT(i < nknots);
		ASSERT(iknot_start + idst < nMaxKnots);
		ptmp_knots[idst++] = pknots[i];

		if(ioverflow != -1)
		{
			if((pknots[i+1] - pknots[i]) >= 2.f)
			{
				// Current knot delta is large enough for another intermediate knot.
				float k = floorf((pknots[i+1] + pknots[i]) * 0.5f);
				ASSERT(k > pknots[i] && k < pknots[i+1]);
				ASSERT(iknot_start + idst < nMaxKnots);
				ptmp_knots[idst++] = k;
				ioverflow = -1;
			}	

			// Regardless, don't bother checking error for this delta.
			continue;
		}

		s32 iend = s32(pknots[i+1]);
		for(icur = max(s32(pknots[i]),icur); icur <= iend; icur++)
		{
			// See if there's unacceptable error within current knot delta.
			float t = (float(icur)) * oo_max_knot;
			ASSERT(pknots[i] <= icur);

			CurveEvalBuf buf;
			ptype->evaluate(cd,t,nEvalFlags,&buf);
			
			float e2 = CurveCalcErrorSq(buf.aCurve,pSamples + icur * nDimensions,nDimensions,nEvalFlags);
			if(e2 > err_tol2)
			{
				// Error tolerance was exceeded, so curve will require another subdivision.
				nres = sr_Continue;

				if((pknots[i+1] - pknots[i]) >= 2.f)
				{
					// Current knot delta is large enough for another intermediate knot.
					float k = floorf((pknots[i+1] + pknots[i]) * 0.5f);
					ASSERT(k > pknots[i] && k < pknots[i+1]);
					ASSERT(iknot_start + idst < nMaxKnots);
					ptmp_knots[idst++] = k;
				}
				else
				{
					// Knot delta is already as small as possible, try overflowing into next knot delta.
					ASSERT((pknots[i+1] - pknots[i]) == 1.f || (pknots[i+1] - pknots[i]) == 0.f);
					ioverflow = i;	
				}
				break;
			}
		}
	}

	ASSERT(iknot_start + idst <= nMaxKnots - 1);

	// Insert final knot.
	ptmp_knots[idst++] = pknots[nknots-1];

	if(ioverflow != -1)
	{
		// Since overflow is normally handled left-to-right, try right-to-left.
		ASSERT(nres == sr_Continue);
		for(s32 i = s32(idst) - 1; i > 0; i--)
		{
			if((ptmp_knots[i] - ptmp_knots[i-1]) >= 2.f)
			{
				float k = floorf((ptmp_knots[i] + ptmp_knots[i-1]) * 0.5f);
				ASSERT(k > ptmp_knots[i-1] && k < ptmp_knots[i]);
				ASSERT(iknot_start + idst < nMaxKnots);
				memmove(ptmp_knots + i + 1,ptmp_knots + i,sizeof(float) * (idst++ - i));
				ptmp_knots[i] = k;
				ioverflow = -1;
				break;	
			}
		}

		if(ioverflow != -1)
		{
			// We're out of knots, but still have error. Further subdivision is pointless.
			nres = sr_Failure;
		}
	}

#if defined(_DEBUG)
	// Knots should be strictly increasing.
	for(u32 k = 0, n = idst - 1; k < n; k++)
	{
		ASSERT(ptmp_knots[k] < ptmp_knots[k+1]);
	}
#endif

	*pcount = idst;
	return nres;
}
///////////////////////////////////////////////////////////////////////////////
CurveData * CurveMaker::reduceCurveKnots(
							const CurveType * ptype,
							u32               iknot_start,
							u32               nknots,
							u32               icur_curve,
							u32 *             pcurve_idx, 
							u32 *             pcurve_size
							)
{
	PROFILE_CURVE_SOLVER_CALL(CurveMaker::reduceCurveKnots);
	ASSERT(nknots >= 2);
	ASSERT(nMakerFlags & cmf_AllowKnotReduction);
	const float err_tol2 = fErrTol * fErrTol;

	CurveData * ptmp_curve = (CurveData *)getCurveData(icur_curve);
	u32         itmp_curve = getNextCurveIndex(icur_curve);

	// Determine which location solver will be writing to.
	float * pctrls = (nMakerFlags & cmf_AllowCuts) ? pTmpCtrls : pCtrls;
	ASSERT(pctrls);

	// Determine samples of interest for current segment.
	const u32     isample_start = u32(pKnots[iknot_start]);
	const u32     nsamples      = u32(pKnots[iknot_start + nknots - 1]) - isample_start + 1;
	const float * psamples      = pSamples + isample_start * nDimensions;
	const float   min_knot      = pKnots[iknot_start];
	const float   max_knot      = pKnots[iknot_start + nknots - 1];

	// Iterate through each non-protected knot and see if removing it would violate error tolerance.
	const s32 protected_knots = (nMakerFlags & cmf_ConstrainEndVel) ? 2 : 1;
	for(s32 iknot = protected_knots; iknot < (s32)nknots - protected_knots; iknot++)
	{
		// Copy elements before current knot.
		float * ptk = pTmpKnots + iknot_start;
		s32 i;
		for(i = 0; i < iknot; i++)
			*ptk++ = pKnots[i + iknot_start];

		// Copy elements after current knot.
		for(i = iknot+1; i < (s32)nknots; i++)
			*ptk++ = pKnots[i + iknot_start];
		
		// Solve controls for current segment.
		solveControls(pTmpKnots,pctrls,iknot_start,nknots - 1);

		// Create curve containing all segments processed so far.
		u32 ncurve_size  = 0;
		u32 ncurve_knots = iknot_start + nknots - 1;
		byte * ploc = getCurveData(itmp_curve);
		CurveData * pcd = ptype->createCurve(
									pTmpKnots,pctrls,
									ncurve_knots,nDimensions,nDegree,
									nEvalFlags,
									&ncurve_size,ploc,nCurveSize);
		
		if(!pcd)
		{
			LOG(lg_Error,"Failed to create curve of type %s.\n",ptype->getName());
			break;
		}

		ASSERT_CONSTRAINTS(*pcd,pTmpKnots,iknot_start,nknots - 1);
		CurveError ce;
		{
			PROFILE_CURVE_SOLVER_CALL(ComputeErrorWithoutKnot);
			ptype->calcError(*pcd,psamples,nsamples,min_knot,max_knot,nEvalFlags,&ce);
		}

		if(ce.fMaxErrSq <= err_tol2)
		{
			// Turns out current knot isn't required afterall.
			mswap(itmp_curve,icur_curve);
			*pcurve_idx  = icur_curve;
			*pcurve_size = ncurve_size;

			ASSERT(nknots > 0);
			nknots--;

			ASSERT(iknot > 0);
			iknot--;

			if(nMakerFlags & cmf_AllowCuts)
			{
				// Copy knot buffer and control buffer into correct location.
				ASSERT(pctrls == pTmpCtrls);
				u32 ctrl_offset = iknot_start * nDimensions, nctrls = nDimensions  * (nknots + nDegree - 1);
				memcpy(pCtrls + ctrl_offset,pTmpCtrls + ctrl_offset,sizeof(float) * nctrls);
				memcpy(pKnots + iknot_start,pTmpKnots + iknot_start,sizeof(float) * nknots);
			}
			else
			{
				// Simple case, just swap knot buffers. 
				ASSERT(pCtrls == pctrls);
				ASSERT(!pTmpCtrls);
				mswap(pKnots,pTmpKnots);
			}

			ASSERT(pcd);
			ptmp_curve = pcd;
		}
	}

	return ptmp_curve;
}
///////////////////////////////////////////////////////////////////////////////
bool CurveMaker::areAllSamplesEqual() const
{
	// Tolerance is set to half, to ensure max error can't exceed true tolerance.
	const float half_tol2 = 
		(nEvalFlags & cef_QuatErrorMetric) ? 
		square(sinf(FastASin(fErrTol) * (0.5f - ZERO_F))):
		square(fErrTol * (0.5f - ZERO_F));

	for(const float * ps = pSamples, * pe = pSamples + nSamples * nDimensions; ps != pe; ps += nDimensions)
	{
		float e2 = CurveCalcErrorSq(pSamples,ps,nDimensions,nEvalFlags);
		if(e2 > half_tol2)
		{
			// Using the first sample will exceed error tolerance.
			// It's theoretically possible choosing some other sample might work,
			// but for now just ignore this possibility.
			return false;
		}
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////
#if defined(_DEBUG)
void CurveMaker::ASSERT_CONSTRAINTS(const CurveData & cd, const float * pknots, u32 iknot_start, u32 nknots) const
{
	const CurveType * ptype = CurveType::get(cd);
	ASSERT(ptype);
	ASSERT((ptype->getFlags() & caf_Constant) == 0);

	// Determine knot interval we're interested in.
	const float min_knot    = pknots[iknot_start];
	const float max_knot    = pknots[iknot_start + nknots - 1];
	const float oo_max_knot = 1.f / max_knot;

	// Determine samples of interest.
	const u32     isample_start = u32(min_knot);
	const u32     nsamples      = u32(max_knot) - isample_start + 1;
	const float * psamples      = pSamples + isample_start * nDimensions;

	// Verify endpoint constraints are correct.
	if(nMakerFlags & cmf_ConstrainEndPos)
	{
		const float tol = (ptype->getFlags() & caf_HiCompression) ? 0.5f : 0.1f;
		CurveEvalBuf buf;

		if(nEvalFlags & cef_Normalize)
		{
			// Samples may not be normalized.
			float norm_samp[MAX_CURVE_DIMENSIONS];
			CopyVectorN(psamples,norm_samp,nDimensions);
			NormalizeVectorSafeN(norm_samp,nDimensions);
			ptype->evaluate(cd,min_knot * oo_max_knot,nEvalFlags,&buf);
			if((nEvalFlags & cef_QuatContinuity) && DotVectorsN(buf.aCurve,norm_samp,nDimensions) < 0.f)
				ScaleVectorN(norm_samp,-1.f,nDimensions);
			ASSERT(AreVectorsEqualN(buf.aCurve,norm_samp,tol,nDimensions));

			CopyVectorN(psamples + (nsamples - 1) * nDimensions,norm_samp,nDimensions);
			NormalizeVectorSafeN(norm_samp,nDimensions);
			ptype->evaluate(cd,1.f,nEvalFlags,&buf);
			if((nEvalFlags & cef_QuatContinuity) && DotVectorsN(buf.aCurve,norm_samp,nDimensions) < 0.f)
				ScaleVectorN(norm_samp,-1.f,nDimensions);
			ASSERT(AreVectorsEqualN(buf.aCurve,norm_samp,tol,nDimensions));
		}
		else
		{
			ptype->evaluate(cd,min_knot * oo_max_knot,nEvalFlags,&buf);
			ASSERT(AreVectorsEqualN(buf.aCurve,psamples,tol,nDimensions));
			ptype->evaluate(cd,1.f,nEvalFlags,&buf);
			ASSERT(AreVectorsEqualN(buf.aCurve,psamples + (nsamples - 1) * nDimensions,tol,nDimensions));
		}
	}

	// If using normalized controls or high compression, all bets are off regarding velocity.
	if((nDegree >= 3) && (ptype->getFlags() & (caf_NormalizedCtrls | caf_HiCompression)) == 0)
	{
		if(nMakerFlags & cmf_ConstrainEndVel)
		{
			// Not using hi-compression or normalized control format, so velocities should be pretty close.
			float v0[MAX_CURVE_DIMENSIONS];
			SubVectorsN(psamples + nDimensions, psamples,v0,nDimensions);
			ScaleVectorN(v0,max_knot,nDimensions);

			CurveEvalBuf buf;
			ptype->differentiate(cd,min_knot * oo_max_knot,1,&buf);
			ASSERT(AreVectorsEqualN(buf.aCurve,v0,0.1f,nDimensions));

			float v1[MAX_CURVE_DIMENSIONS];
			SubVectorsN(psamples + nDimensions * (nsamples - 1), psamples + nDimensions * (nsamples - 2),v1,nDimensions);
			ScaleVectorN(v1,max_knot,nDimensions);
			ptype->differentiate(cd,1.f,1,&buf);
			ASSERT(AreVectorsEqualN(buf.aCurve,v1,0.1f,nDimensions));
		}
	}
}
#endif
///////////////////////////////////////////////////////////////////////////////
void CurveMaker::solveControls(const float * pknots,float * pctrls,u32 iknot_start,u32 nknots)
{
	PROFILE_CURVE_SOLVER_CALL(CurveMaker::solveControls);
	ASSERT((nknots >= 2) && (iknot_start + nknots <= nMaxKnots));
	
	const u32 dof = nDegree - 1;
	const u32 n   = nknots + dof;
	const u32 d   = nDimensions;

	// Determine samples of interest for current segment.
	const u32     isample_start = u32(pknots[iknot_start]);
	const u32     nsamples      = u32(pknots[iknot_start + nknots - 1]) - isample_start + 1;
	const float * psamples      = pSamples + isample_start * d;

	if(nMakerFlags & cmf_DoublePrecisionSolver)
	{
		ASSERT(n * d * sizeof(double) <= nSolutionVectorSize);
		ASSERT(n * n * sizeof(double) <= nSolutionMatrixSize);

		CurveSolveControls(
			pknots + iknot_start,nknots,
			psamples,nsamples,
			nDegree,d,
			getSolutionMatrix<double>(),
			getSolutionVector<double>(),
			getTmpMatrix<double>(),
			getCholeskyDivisors<double>(),
			pKnotIndices
			);

		// Copy double precision solution vector to single precision control area.
		// Non-optimal, but you're using doubles, so what do you care?
		float RESTRICT_PTR pc = pctrls + iknot_start * d;
		const double * pv = getSolutionVector<double>();
		const double * pe = pv + d * n;
		while(pv != pe)
			*pc++ = float(*pv++);
	}
	else
	{
		ASSERT(n * d * sizeof(float) <= nSolutionVectorSize);
		ASSERT(n * n * sizeof(float) <= nSolutionMatrixSize);

		// Write to provided control buffer.
		CurveSolveControls(
			pknots + iknot_start,nknots,
			psamples,nsamples,
			nDegree,d,
			getSolutionMatrix<float>(),
			pctrls + iknot_start * d,
			getTmpMatrix<float>(),
			getCholeskyDivisors<float>(),
			pKnotIndices
			);
	}

	// Advance pointers to start of work area.
	pctrls += iknot_start * d;
	pknots += iknot_start;

	if(nMakerFlags & cmf_ConstrainEndPos)
	{
		// Force curve endpoints to match first and last samples, respectively.
		for(u32 i = 0; i < d; i++)
		{
			pctrls[i] = psamples[i];
			pctrls[d * (n-1) + i] = psamples[d * (nsamples - 1) + i];
		}
	}

	// For now, only enforce velocity constraints if degree 3 or higher.
	if((nMakerFlags & cmf_ConstrainEndVel) && (nDegree >= 3))
	{
		// Force initial curve velocity to match initial sample velocity.
		const float kd0_over_deg = (pknots[1] - pknots[0]) / float(nDegree);
		for(u32 i = 0; i < d; i++)
		{
			const float ds = psamples[d + i] - psamples[i];
			pctrls[d + i] = pctrls[i] + ds * kd0_over_deg;
		}

		// Force final curve velocity to match final sample velocity.
		const float kd1_over_deg = (pknots[nknots - 1] - pknots[nknots - 2]) / float(nDegree);
		for(u32 i = 0; i < d; i++)
		{
			const float ds = psamples[d * (nsamples - 1) + i] - psamples[d * (nsamples - 2) + i];
			pctrls[d * (n-2) + i] = pctrls[d * (n-1) + i] - ds * kd1_over_deg;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
CurveData * CurveMaker::makeCompressedCurve(
							const float *      psamples,
							u32                nsamples,
							u32                dimensions,
							u32                degree,
							u32                maker_flags,
							u32                eval_flags,
							float              err_tol,
							float              cut_tol,
							bool *             phit_tol,
							u32 *              psize,
							const CurveType ** pptypes, 
							u32                ntypes
							)
{
	// Store parameters so we don't have to pass them around.
	PROFILE_CURVE_SOLVER_CALL(CurveMaker::makeCompressedCurve);
	ASSERT(psamples);
	pSamples    = psamples;
	nSamples    = nsamples;
	nDimensions = dimensions;
	nDegree     = degree;
	nMakerFlags = maker_flags;
	nEvalFlags  = eval_flags;
	fErrTol     = err_tol;
	fCutTol     = cut_tol;
	nMaxKnots   = (nMakerFlags & cmf_AllowCuts) ? nSamples * (nDegree + 1) : nSamples;
	nMaxCurves  = (nMakerFlags & cmf_AllowKnotReduction) ? 3 : 2;

	if(nDimensions > MAX_CURVE_DIMENSIONS)
	{
		LOG(lg_Error, "Requested curve dimensions are %d, but max dimensions are %d.\n",nDimensions,MAX_CURVE_DIMENSIONS);
		return NULL;
	}

	if(nDegree > MAX_CURVE_DEGREE)
	{
		LOG(lg_Error, "Requested curve degree is %d, but max degree is %d.\n",nDegree,MAX_CURVE_DEGREE);
		return NULL;
	}

	// Because of numerical imprecision, specifying a zero error tolerance can produce very large curves.
	// To deal with this, enforce a minimum tolerance that can reasonably be achieved with 32-bit floats.
	const float min_err_tol = (nEvalFlags & cef_QuatErrorMetric) ? CurveRadToQuatErrorMetric(fMinAngErrTol) : fMinLinErrTol;
	fErrTol = max(fErrTol,min_err_tol);

	const u32 precision_size = (nMakerFlags & cmf_DoublePrecisionSolver) ? sizeof(double) : sizeof(float);
	const u32 dof = nDegree - 1;
	const u32 nmax_ctrls = nMaxKnots + dof;
	
	// Setup all memory work areas, allocated out of a single blob.
	nKnotsSize              = sizeof(float) * nMaxKnots;
	nKnotIndicesSize        = sizeof(s32) * nMaxKnots;
	nCtrlsSize              = sizeof(float) * nDimensions * nmax_ctrls;
	nCurveSize              = MAX_CURVE_HEADER_SIZE + nKnotsSize + nCtrlsSize;
	nTmpMatrixSize          = precision_size * nmax_ctrls * nmax_ctrls;
	nCholeskyDivisorsSize   = precision_size * nmax_ctrls;
	nSolutionMatrixSize     = precision_size * nmax_ctrls * nmax_ctrls;
	nSolutionVectorSize     = precision_size * nDimensions * nmax_ctrls; 

	nKnotIndicesOffset      = nKnotsSize * 2;
	nCurveOffset            = nKnotIndicesOffset + nKnotIndicesSize;
	nTmpMatrixOffset        = nCurveOffset + nCurveSize * nMaxCurves;
	nCholeskyDivisorsOffset = nTmpMatrixOffset + nTmpMatrixSize;
	nSolutionMatrixOffset   = nCholeskyDivisorsOffset + nCholeskyDivisorsSize; 
	nSolutionVectorOffset   = nSolutionMatrixOffset + nSolutionMatrixSize;

	if(nMakerFlags & cmf_DoublePrecisionSolver)
	{
		// We need additional space for controls if in double precision mode.
		nCtrlsOffset = nSolutionVectorOffset + nSolutionVectorSize;
	}
	else
	{
		// In single precision mode, solution vector and controls alias each other.
		ASSERT(nCtrlsSize <= nSolutionVectorSize);
		nCtrlsOffset = nSolutionVectorOffset;
	}

	u32 ndata_size = nCtrlsOffset + nCtrlsSize;
	u32 ntmp_ctrls_offset = (u32)-1;

	if((nMakerFlags & (cmf_AllowCuts | cmf_AllowKnotReduction)) == (cmf_AllowCuts | cmf_AllowKnotReduction))
	{
		// Each curve segment is run through solver individually.
		// However, this means we need to keep track of previously solved segments.
		// Therefore, reserve space that knot reduction can write to without corrupting solved controls.
		ndata_size += nCtrlsSize;
		ntmp_ctrls_offset = nCtrlsOffset;
	}

	aData.resize(ndata_size);

	pCtrls       = (float *)&aData[nCtrlsOffset];
	pTmpCtrls    = (ntmp_ctrls_offset != (u32)-1) ? (float *)&aData[nCtrlsOffset + nCtrlsSize] : NULL;
	pKnots       = (float *)&aData[0];
	pTmpKnots    = (float *)&aData[nKnotsSize];
	pKnotIndices = (s32 *)&aData[nKnotIndicesOffset];

	if((nMakerFlags & cmf_Constant) == 0 && areAllSamplesEqual())
		nMakerFlags |= cmf_Constant;

	const float err_tol2 = fErrTol * fErrTol;
	CurveType const * atypes[ct_MaxTypes];
	
	if(!pptypes)
	{
		ntypes  = CurveType::getSupportTypes(nDimensions,nSamples,atypes);
		pptypes = atypes;
	}

	if(!ntypes)
	{
		LOG(lg_Error, "No curve types support requested specifications.\n");
		return NULL;
	}

	CurveData * pcur_curve = NULL;
	u32   icur_curve = 0;
	u32   ncur_size  = 0;
	float cur_err2   = FLT_MAX;

	for(u32 i = 0; i < ntypes; i++)
	{
		CurveData * ptmp_curve = NULL;
		u32 itmp_curve = getNextCurveIndex(icur_curve);
		u32 ntmp_size  = 0;

		const CurveType * ptype = pptypes[i];

		if(ptype->getFlags() & caf_Constant)
		{
			// Type is constant, so we can use the first sample directly, and don't need any knots.
			ptmp_curve = ptype->createCurve(
									NULL,pSamples,
									1,nDimensions,nDegree,
									nEvalFlags,
									&ntmp_size,getCurveData(itmp_curve),nCurveSize);
		}
		else
		{
			if(nMakerFlags & cmf_Constant)
			{
				// Type isn't constant, so we need to construct knot and control buffers.
				float ctrl_buf[MAX_CURVE_DIMENSIONS * (MAX_CURVE_DEGREE + 1)];
				float knot_buf[2] = { 0.f, 1.f };
				ASSERT(nDegree + 1 <= MAX_CURVE_DEGREE + 1);

				float * pc = ctrl_buf;
				const float * pe = ctrl_buf + nDimensions * (nDegree + 1);
				while(pc != pe)
				{
					for(u32 k = 0; k < nDimensions; k++)
						*pc++ = pSamples[k];
				}

				ptmp_curve = ptype->createCurve(
										knot_buf,ctrl_buf,
										2,nDimensions,nDegree,
										nEvalFlags,
										&ntmp_size,getCurveData(itmp_curve),nCurveSize);
			}
			else
			{
				// Normal case, attempt to fit curve to samples.
				ptmp_curve = fitCurve(ptype,icur_curve,&itmp_curve,&ntmp_size);
			}
		}

#if defined(_DEBUG)
		if(pcur_curve)
		{
			CurveError ce;
			CurveType::get(*pcur_curve)->calcError(*pcur_curve,pSamples,nSamples,0.f,float(nSamples-1),nEvalFlags,&ce);
			ASSERT(ce.fMaxErrSq == cur_err2);
		}
#endif

		if(ptmp_curve)
		{
			CurveError ce;
			ptype->calcError(*ptmp_curve,pSamples,nSamples,0.f,float(nSamples - 1),nEvalFlags,&ce);

			if((ce.fMaxErrSq < cur_err2 && cur_err2 > err_tol2) || (ntmp_size < ncur_size && ce.fMaxErrSq <= err_tol2))
			{
				// Either current curve is the first curve within error tolerance, 
				// or it's smaller and also within tolerance.
				ASSERT(itmp_curve != (u32)-1);
				pcur_curve = ptmp_curve;
				icur_curve = itmp_curve;
				ncur_size  = ntmp_size;
				cur_err2   = ce.fMaxErrSq;
			}
		}
	}

	if(phit_tol)
		*phit_tol = (cur_err2 <= err_tol2);

	if(psize) 
		*psize = ncur_size;

	return pcur_curve;
}
///////////////////////////////////////////////////////////////////////////////
